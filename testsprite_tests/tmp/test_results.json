[
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "d4de4e50-af31-4ee8-a2fc-c8ee013c8c89",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC001-get_basic_health_check",
    "description": "Verify the /health GET endpoint returns server health status with a 200 response including status and timestamp.",
    "code": "import requests\n\ndef test_get_basic_health_check():\n    base_url = \"http://localhost:3001\"\n    url = f\"{base_url}/health\"\n    headers = {'Accept': 'application/json'}\n    timeout = 30\n\n    try:\n        response = requests.get(url, headers=headers, timeout=timeout)\n        # Validate HTTP status code\n        assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n        json_response = response.json()\n        # Validate required fields exist\n        assert \"status\" in json_response, \"'status' field missing in response\"\n        assert \"timestamp\" in json_response, \"'timestamp' field missing in response\"\n        # Validate 'status' is not empty and is a string\n        assert isinstance(json_response[\"status\"], str) and json_response[\"status\"], \"'status' field should be a non-empty string\"\n        # Validate 'timestamp' is a string (Further datetime format validation can be added if needed)\n        assert isinstance(json_response[\"timestamp\"], str) and json_response[\"timestamp\"], \"'timestamp' field should be a non-empty string\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\ntest_get_basic_health_check()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.769Z",
    "modified": "2026-01-09T20:40:13.111Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "290da3bb-a05f-4e91-a509-375cb0aa124d",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC002-get_detailed_health_check_with_clickup_status",
    "description": "Verify the /api/health GET endpoint returns detailed server health including ClickUp connection status, user info, and timestamp with a 200 response.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\ndef test_get_detailed_health_check_with_clickup_status():\n    url = f\"{BASE_URL}/api/health\"\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    try:\n        response = requests.get(url, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request to {url} failed with exception: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not in JSON format\"\n\n    # Validate expected keys in the response for detailed health status\n    assert isinstance(data, dict), \"Response JSON is not a dictionary\"\n\n    # Check for 'clickup' key and structure\n    assert \"clickup\" in data, \"'clickup' key missing in response\"\n    clickup_status = data[\"clickup\"]\n    assert isinstance(clickup_status, dict), \"'clickup' field is not an object\"\n    assert \"status\" in clickup_status, \"'status' missing in clickup data\"\n    connection_status = clickup_status[\"status\"]\n    assert isinstance(connection_status, str), \"'status' should be a string\"\n\n    # Check for 'timestamp' key\n    assert \"timestamp\" in data, \"'timestamp' key missing in response\"\n    timestamp = data[\"timestamp\"]\n    assert isinstance(timestamp, str), \"'timestamp' should be a string\"\n\ntest_get_detailed_health_check_with_clickup_status()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.774Z",
    "modified": "2026-01-09T20:43:45.604Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "25859d1f-fa98-4b56-a8f9-31eff924129d",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC003-get_webhook_enabled_status",
    "description": "Verify the /api/webhook/status GET endpoint returns the current webhook enabled or disabled state with a 200 response.",
    "code": "import requests\n\ndef test_get_webhook_enabled_status():\n    base_url = \"http://localhost:3001\"\n    url = f\"{base_url}/api/webhook/status\"\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n\n    try:\n        response = requests.get(url, headers=headers, timeout=30)\n        response.raise_for_status()\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request to {url} failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    assert \"enabled\" in data, \"Response JSON does not contain 'enabled' key\"\n    assert isinstance(data[\"enabled\"], bool), \"'enabled' key should be of boolean type\"\n\ntest_get_webhook_enabled_status()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.780Z",
    "modified": "2026-01-09T20:40:13.400Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "f9bb1fa7-5d0b-4423-adde-850ebdae01ff",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC004-post_toggle_webhook_state",
    "description": "Verify the /api/webhook/toggle POST endpoint toggles the webhook state and returns the new state and a confirmation message with a 200 response.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\ndef test_post_toggle_webhook_state():\n    url = f\"{BASE_URL}/api/webhook/toggle\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    payload = {\n        \"webhookId\": \"example-webhook-id\"\n    }\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected 200, got {response.status_code}\"\n\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    assert ('newState' in data and isinstance(data[\"newState\"], bool)) or ('state' in data and isinstance(data[\"state\"], bool)), \"Response JSON missing 'newState' or 'state' field with boolean value\"\n\n    assert \"message\" in data, \"Response JSON missing 'message' field\"\n    assert isinstance(data[\"message\"], str), \"'message' should be a string\"\n    assert len(data[\"message\"]) > 0, \"'message' should not be empty\"\n\ntest_post_toggle_webhook_state()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 33, in <module>\n  File \"<string>\", line 27, in test_post_toggle_webhook_state\nAssertionError: Response JSON missing 'newState' or 'state' field with boolean value\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.785Z",
    "modified": "2026-01-09T20:43:52.374Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "25ab6501-1a01-4686-8d14-e4166e25040b",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC005-post_enable_webhook",
    "description": "Verify the /api/webhook/enable POST endpoint enables the webhook and returns a 200 response confirming the action.",
    "code": "import requests\n\ndef test_post_enable_webhook():\n    base_url = \"http://localhost:3001\"\n    url = f\"{base_url}/api/webhook/enable\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    try:\n        response = requests.post(url, headers=headers, timeout=30)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request to enable webhook failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n    # Assuming that the response JSON contains a confirmation message or status field\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Check if confirmation/action field exists and indicates success\n    assert (\n        \"message\" in data or \"status\" in data or \"enabled\" in data\n    ), \"Response JSON does not contain expected confirmation fields\"\n    # If 'enabled' field is present, it should be True\n    if \"enabled\" in data:\n        assert data[\"enabled\"] is True, \"Webhook enabled flag is not True\"\n    if \"status\" in data:\n        assert data[\"status\"].lower() in [\"enabled\", \"success\", \"ok\"], f\"Unexpected status value: {data['status']}\"\n    if \"message\" in data:\n        assert isinstance(data[\"message\"], str) and len(data[\"message\"]) > 0, \"Message field is empty or invalid\"\n\ntest_post_enable_webhook()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.790Z",
    "modified": "2026-01-09T20:40:13.675Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "906b0eaf-c6e1-4355-a2d6-2ac80c581a0b",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC006-post_disable_webhook",
    "description": "Verify the /api/webhook/disable POST endpoint disables the webhook and returns a 200 response confirming the action.",
    "code": "import requests\n\ndef test_post_disable_webhook():\n    base_url = \"http://localhost:3001\"\n    url = f\"{base_url}/api/webhook/disable\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    timeout = 30\n    try:\n        response = requests.post(url, headers=headers, timeout=timeout)\n        response.raise_for_status()\n        # Assert status code is 200\n        assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n        # Assert response content confirms the action (assuming JSON with message or status)\n        json_resp = response.json()\n        assert isinstance(json_resp, dict), \"Response is not a JSON object\"\n        # Check for a confirming key or message\n        confirmation_keys = [\"message\", \"status\", \"success\"]\n        assert any(key in json_resp for key in confirmation_keys), \"Response missing confirmation message or status\"\n        # If message exists, check it contains disable-related text\n        message = json_resp.get(\"message\") or \"\"\n        status = json_resp.get(\"status\") or \"\"\n        success = json_resp.get(\"success\")\n        assert (\"disable\" in message.lower() or \"disabled\" in message.lower() or \n                \"disable\" in status.lower() or success is True), \"Response does not confirm webhook was disabled\"\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_post_disable_webhook()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.796Z",
    "modified": "2026-01-09T20:40:14.802Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "eaaf58b2-36bb-41be-a036-cdc9d8b7edd6",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC007-post_receive_clickup_webhook_events",
    "description": "Verify the /webhook/clickup POST endpoint correctly processes incoming ClickUp webhook events with event, task_id, and webhook_id in the payload and returns a 200 response.",
    "code": "import requests\n\ndef test_post_receive_clickup_webhook_events():\n    base_url = \"http://localhost:3001\"\n    endpoint = \"/webhook/clickup\"\n    url = base_url + endpoint\n\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    payload = {\n        \"event\": \"taskCreated\",\n        \"task_id\": \"123456789\",\n        \"webhook_id\": \"abcdef123456\"\n    }\n\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=30)\n        assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n        # Additional content validation can be done here if API returns content.\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_post_receive_clickup_webhook_events()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.805Z",
    "modified": "2026-01-09T20:40:15.096Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "c20b18a0-b3cb-43e4-9367-c541de139564",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC008-get_initiate_clickup_oauth_flow",
    "description": "Verify the /auth/clickup GET endpoint initiates the OAuth flow by redirecting to ClickUp authorization with a 302 response.",
    "code": "import requests\n\ndef test_get_initiate_clickup_oauth_flow():\n    base_url = \"http://localhost:3001\"\n    url = f\"{base_url}/auth/clickup\"\n    timeout = 30\n    try:\n        response = requests.get(url, timeout=timeout, allow_redirects=False)\n    except requests.RequestException as e:\n        assert False, f\"Request to {url} failed with exception: {str(e)}\"\n    \n    assert response.status_code == 302, f\"Expected status code 302, got {response.status_code}\"\n    location = response.headers.get(\"Location\")\n    assert location is not None, \"Response missing 'Location' header for redirect\"\n    # Validate that the redirect is to ClickUp authorization URL (basic check)\n    assert \"clickup.com\" in location.lower() and \"oauth\" in location.lower(), \\\n        f\"Redirect location does not appear to be a ClickUp OAuth URL: {location}\"\n\ntest_get_initiate_clickup_oauth_flow()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 19, in <module>\n  File \"<string>\", line 12, in test_get_initiate_clickup_oauth_flow\nAssertionError: Expected status code 302, got 200\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.811Z",
    "modified": "2026-01-09T20:40:18.901Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "7a032d78-5669-4ea8-828c-8c9143df94b4",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC009-get_clickup_oauth_callback_handling",
    "description": "Verify the /auth/clickup/callback GET endpoint correctly handles OAuth callback with code or error query parameters, returning 200 on success and 400 on error.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\ndef test_get_clickup_oauth_callback_handling():\n    # Test success case with 'code' query parameter\n    params_success = {'code': 'valid_oauth_code_example'}\n    try:\n        response = requests.get(f\"{BASE_URL}/auth/clickup/callback\", params=params_success, timeout=TIMEOUT)\n        assert response.status_code == 200, f\"Expected 200 OK on success, got {response.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed during success case: {e}\"\n\n    # Test error case with 'error' query parameter\n    params_error = {'error': 'access_denied'}\n    try:\n        response = requests.get(f\"{BASE_URL}/auth/clickup/callback\", params=params_error, timeout=TIMEOUT)\n        assert response.status_code == 400, f\"Expected 400 Bad Request on error, got {response.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed during error case: {e}\"\n\n    # Test edge case with both 'code' and 'error' parameters set (should treat as error)\n    params_conflict = {'code': 'somecode', 'error': 'someerror'}\n    try:\n        response = requests.get(f\"{BASE_URL}/auth/clickup/callback\", params=params_conflict, timeout=TIMEOUT)\n        # Assuming error has priority, expect 400\n        assert response.status_code == 400, f\"Expected 400 Bad Request when both code and error present, got {response.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed during conflict case: {e}\"\n\n    # Test case with neither 'code' nor 'error' params (likely invalid request, expect 400)\n    try:\n        response = requests.get(f\"{BASE_URL}/auth/clickup/callback\", timeout=TIMEOUT)\n        assert response.status_code == 400, f\"Expected 400 Bad Request when no query params, got {response.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed during missing params case: {e}\"\n\ntest_get_clickup_oauth_callback_handling()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 11, in test_get_clickup_oauth_callback_handling\nAssertionError: Expected 200 OK on success, got 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.818Z",
    "modified": "2026-01-09T20:40:18.916Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "727ffdc9-2b63-4ddd-b9bd-dbc1f01493f3",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC010-get_all_tasks",
    "description": "Verify the /api/tasks GET endpoint returns a list of all tasks with a 200 response.",
    "code": "import requests\n\ndef test_get_all_tasks():\n    base_url = \"http://localhost:3001\"\n    url = f\"{base_url}/api/tasks\"\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    try:\n        response = requests.get(url, headers=headers, timeout=30)\n        response.raise_for_status()\n        assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n        data = response.json()\n        assert isinstance(data, list), f\"Expected response body to be a list but got {type(data)}\"\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_get_all_tasks()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.823Z",
    "modified": "2026-01-09T20:40:16.751Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "9d3557a8-d2b9-440e-ad30-4f1ffd19f745",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC011-Demo Creation - Slug Availability Check",
    "description": "Verify GET /api/demo/check-slug endpoint correctly checks if a slug is available, returns available=true for new slugs, available=false for existing/reserved slugs, and handles validation errors with appropriate status codes.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\nHEADERS = {\n    \"Accept\": \"application/json\"\n}\n\n\ndef test_demo_creation_slug_availability_check():\n    \"\"\"\n    Verify GET /api/demo/check-slug endpoint correctly:\n    - returns available=true for new slugs\n    - returns available=false for existing or reserved slugs\n    - handles validation errors with appropriate status codes\n    \"\"\"\n    url = f\"{BASE_URL}/api/demo/check-slug\"\n\n    # Test with a new unique slug which should be available\n    new_slug = \"unique-new-slug-test-123\"\n    try:\n        resp = requests.get(url, params={\"slug\": new_slug}, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        data = resp.json()\n        assert isinstance(data, dict), \"Response JSON should be an object\"\n        assert \"available\" in data, \"Response JSON must include 'available'\"\n        assert data[\"available\"] is True, f\"Slug '{new_slug}' should be available\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed for new slug availability check: {e}\"\n\n    # Test with an existing or reserved slug which should NOT be available\n    # We assume \"admin\" is reserved for this test\n    reserved_slugs = [\"admin\"]\n    for slug in reserved_slugs:\n        try:\n            resp = requests.get(url, params={\"slug\": slug}, headers=HEADERS, timeout=TIMEOUT)\n            # For existing slug, the API should still return 200 but available=False\n            resp.raise_for_status()\n            data = resp.json()\n            assert isinstance(data, dict), \"Response JSON should be an object\"\n            assert \"available\" in data, \"Response JSON must include 'available'\"\n            assert data[\"available\"] is False, f\"Slug '{slug}' should NOT be available\"\n        except requests.RequestException as e:\n            assert False, f\"Request failed for reserved slug '{slug}': {e}\"\n\n    # Test validation error cases: missing slug parameter\n    try:\n        resp = requests.get(url, headers=HEADERS, timeout=TIMEOUT)\n        # Expect a 400 Bad Request or another client error code due to missing slug param\n        assert resp.status_code in {400, 422}, f\"Missing slug parameter should return 400 or 422, got {resp.status_code}\"\n        # Response should have error details\n        try:\n            error_data = resp.json()\n            assert \"error\" in error_data or \"message\" in error_data, \"Response should contain error or message field\"\n        except Exception:\n            pass  # JSON parse not mandatory, but preferred\n    except requests.RequestException as e:\n        assert False, f\"Request failed for missing slug param case: {e}\"\n\n    # Test validation error cases: invalid slug format (e.g. with spaces or special chars)\n    invalid_slugs = [\"invalid slug!\", \"with@chars#\", \"space slug\", \"!@#$$%^&*()\"]\n    for inv_slug in invalid_slugs:\n        try:\n            resp = requests.get(url, params={\"slug\": inv_slug}, headers=HEADERS, timeout=TIMEOUT)\n            if resp.status_code == 200:\n                data = resp.json()\n                assert isinstance(data, dict), \"Response JSON should be an object\"\n                assert \"available\" in data, \"Response JSON must include 'available'\"\n                # Allow either True or False for available here since server behavior varies\n                assert isinstance(data[\"available\"], bool), f\"'available' must be boolean for slug '{inv_slug}'\"\n            else:\n                assert resp.status_code in {400, 422}, f\"Invalid slug '{inv_slug}' should return 400 or 422, got {resp.status_code}\"\n        except requests.RequestException as e:\n            assert False, f\"Request failed for invalid slug '{inv_slug}': {e}\"\n\n\ntest_demo_creation_slug_availability_check()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.829Z",
    "modified": "2026-01-09T20:45:56.900Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "36d9abd5-0853-49c3-862a-154ddc13ede1",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC012-Demo Creation - GitHub Repository Validation",
    "description": "Verify POST /api/git/test-repo endpoint validates GitHub repository accessibility, returns success=true for accessible public repos, returns 404 with error for private/invalid repos, and handles timeout scenarios correctly.",
    "code": "import requests\nfrom requests.exceptions import Timeout, RequestException\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\ndef test_demo_creation_github_repository_validation():\n    url = f\"{BASE_URL}/api/git/test-repo\"\n    headers = {\"Content-Type\": \"application/json\"}\n\n    # Test case 1: Accessible public repo => success = true\n    public_repo_payload = {\"githubRepoUrl\": \"https://github.com/octocat/Hello-World\"}\n    try:\n        resp = requests.post(url, json=public_repo_payload, headers=headers, timeout=TIMEOUT)\n        resp.raise_for_status()\n        data = resp.json()\n        assert resp.status_code == 200, f\"Expected status 200, got {resp.status_code}\"\n        assert \"success\" in data, \"'success' not in response\"\n        assert data[\"success\"] is True, \"Expected success=true for public repo\"\n    except RequestException as e:\n        assert False, f\"Request failed for accessible public repo test: {e}\"\n\n    # Test case 2: Private or invalid repo => 404 with error message\n    invalid_repo_payload = {\"githubRepoUrl\": \"https://github.com/octocat/ThisRepoDoesNotExist\"}\n    try:\n        resp = requests.post(url, json=invalid_repo_payload, headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 404, f\"Expected status 404 for invalid repo, got {resp.status_code}\"\n        data = resp.json()\n        assert \"error\" in data, \"Expected 'error' field in response for invalid repo\"\n        assert isinstance(data[\"error\"], str) and len(data[\"error\"]) > 0, \"Error message missing or empty\"\n    except RequestException as e:\n        assert False, f\"Request failed for private/invalid repo test: {e}\"\n\n    # Test case 3: Timeout handling - simulate by using a very low timeout\n    try:\n        # Intentionally using 0.001s timeout to simulate timeout scenario\n        requests.post(url, json=public_repo_payload, headers=headers, timeout=0.001)\n        assert False, \"Expected timeout exception but request succeeded\"\n    except Timeout:\n        # Expected outcome\n        pass\n    except RequestException as e:\n        assert False, f\"Unexpected exception type: {e}\"\n\ntest_demo_creation_github_repository_validation()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connection.py\", line 198, in _new_conn\n    sock = connection.create_connection(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/connection.py\", line 85, in create_connection\n    raise err\n  File \"/var/task/urllib3/util/connection.py\", line 73, in create_connection\n    sock.connect(sa)\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 493, in _make_request\n    conn.request(\n  File \"/var/task/urllib3/connection.py\", line 494, in request\n    self.endheaders()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1333, in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1093, in _send_output\n    self.send(msg)\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1037, in send\n    self.connect()\n  File \"/var/task/urllib3/connection.py\", line 325, in connect\n    self.sock = self._new_conn()\n                ^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 207, in _new_conn\n    raise ConnectTimeoutError(\nurllib3.exceptions.ConnectTimeoutError: (<urllib3.connection.HTTPConnection object at 0x7fe4484e3fb0>, 'Connection to tun.testsprite.com timed out. (connect timeout=0.001)')\n\nThe above exception was the direct cause of the following exception:\n\nurllib3.exceptions.ProxyError: ('Unable to connect to proxy', ConnectTimeoutError(<urllib3.connection.HTTPConnection object at 0x7fe4484e3fb0>, 'Connection to tun.testsprite.com timed out. (connect timeout=0.001)'))\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 519, in increment\n    raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nurllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Max retries exceeded with url: http://localhost:3001/api/git/test-repo (Caused by ProxyError('Unable to connect to proxy', ConnectTimeoutError(<urllib3.connection.HTTPConnection object at 0x7fe4484e3fb0>, 'Connection to tun.testsprite.com timed out. (connect timeout=0.001)')))\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 37, in test_demo_creation_github_repository_validation\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 694, in send\n    raise ProxyError(e, request=request)\nrequests.exceptions.ProxyError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Max retries exceeded with url: http://localhost:3001/api/git/test-repo (Caused by ProxyError('Unable to connect to proxy', ConnectTimeoutError(<urllib3.connection.HTTPConnection object at 0x7fe4484e3fb0>, 'Connection to tun.testsprite.com timed out. (connect timeout=0.001)')))\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 45, in <module>\n  File \"<string>\", line 43, in test_demo_creation_github_repository_validation\nAssertionError: Unexpected exception type: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Max retries exceeded with url: http://localhost:3001/api/git/test-repo (Caused by ProxyError('Unable to connect to proxy', ConnectTimeoutError(<urllib3.connection.HTTPConnection object at 0x7fe4484e3fb0>, 'Connection to tun.testsprite.com timed out. (connect timeout=0.001)')))\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.834Z",
    "modified": "2026-01-09T20:40:20.345Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "59628128-11bd-401e-bb98-b9b23fcf6763",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC013-Demo Creation - Validation and Required Fields",
    "description": "Verify POST /api/demo/create endpoint validates required fields (businessName, primaryColor, templateId or githubRepoUrl), validates hex color format, validates slug pattern, returns 400 with appropriate error messages for invalid inputs, and checks slug availability to prevent race conditions.",
    "code": "",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.840Z",
    "modified": "2026-01-09T20:39:21.840Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "18e0ff7b-a79e-40a9-a2fe-a8dd49223a7b",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC014-Demo Creation - Initial Response and Background Processing",
    "description": "Verify POST /api/demo/create endpoint returns immediate 200 response with clientSlug and status='starting' when valid data is provided, initiates background demo creation process without blocking the response, and returns proper error handling for background failures.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:3001\"\nDEMOS_ENDPOINT = \"/api/demo/create\"\nCHECK_SLUG_ENDPOINT = \"/api/demo/check-slug\"\nHEADERS = {\"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\n\ndef test_demo_creation_initial_response_and_background_processing():\n    import uuid\n\n    # Generate a unique slug to avoid conflicts\n    unique_slug = f\"testclient-{uuid.uuid4().hex[:8]}\"\n\n    # Prepare valid payload for demo creation\n    payload = {\n        \"businessName\": \"Test Business Inc.\",\n        \"primaryColor\": \"#123ABC\",\n        \"templateId\": \"template-001\",\n        \"clientSlug\": unique_slug\n    }\n\n    # Step 1: Check that slug is available before creation to avoid race conditions (based on PRD validation criteria)\n    try:\n        r_check = requests.get(\n            f\"{BASE_URL}{CHECK_SLUG_ENDPOINT}\",\n            params={\"slug\": unique_slug},\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        r_check.raise_for_status()\n        resp_check = r_check.json()\n        assert \"available\" in resp_check\n        assert resp_check[\"available\"] is True, f\"Slug {unique_slug} unexpectedly already exists\"\n    except requests.RequestException as e:\n        assert False, f\"Failed to check slug availability: {str(e)}\"\n    except AssertionError as e:\n        assert False, str(e)\n\n    client_slug_created = None\n\n    try:\n        # Step 2: POST to create demo, expect immediate HTTP 200 with status='starting' and clientSlug\n        resp = requests.post(\n            f\"{BASE_URL}{DEMOS_ENDPOINT}\",\n            json=payload,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        # Assert immediate HTTP 200\n        assert resp.status_code == 200, f\"Expected 200, got {resp.status_code}\"\n        resp_json = resp.json()\n        # Validate response keys and values\n        assert \"clientSlug\" in resp_json, \"Response missing 'clientSlug'\"\n        assert \"status\" in resp_json, \"Response missing 'status'\"\n        assert resp_json[\"clientSlug\"] == unique_slug, \"Returned clientSlug does not match request\"\n        assert resp_json[\"status\"] == \"starting\", f\"Expected status 'starting', got {resp_json['status']}\"\n        client_slug_created = resp_json[\"clientSlug\"]\n\n        # Step 3: Background processing starts without blocking response. \n        # Because it is background, simulate waiting and polling status endpoint to verify it progresses.\n        # We expect the demo creation background process eventually changes status from 'starting' to other states.\n\n        STATUS_ENDPOINT = f\"{BASE_URL}/api/demo/status/{client_slug_created}\"\n\n        # Poll status endpoint up to 2 minutes waiting for status not 'starting' (allowing background task processing)\n        # We'll try every 5 seconds.\n        max_wait_secs = 120\n        poll_interval = 5\n        elapsed = 0\n        last_status = None\n        while elapsed < max_wait_secs:\n            try:\n                r_status = requests.get(STATUS_ENDPOINT, timeout=TIMEOUT)\n                if r_status.status_code == 200:\n                    status_json = r_status.json()\n                    last_status = status_json.get(\"state\") or status_json.get(\"status\") or status_json.get(\"status\")\n                    if last_status and last_status != \"starting\":\n                        break  # Background process has progressed\n                else:\n                    # If 404, demo might not be immediately available - continue waiting\n                    if r_status.status_code == 404:\n                        pass\n                    else:\n                        assert False, f\"Unexpected status code polling demo status: {r_status.status_code}\"\n            except requests.RequestException:\n                # Ignore transient errors during polling\n                pass\n            time.sleep(poll_interval)\n            elapsed += poll_interval\n\n        # Step 4: Assert that background process moved demo status beyond 'starting' (or at least status endpoint returns valid response)\n        assert last_status is not None, \"Did not get any status response from background processing\"\n        assert last_status != \"starting\", f\"Background demo creation process did not start properly, status: {last_status}\"\n\n    finally:\n        # Cleanup: Delete the created demo resource to avoid test pollution\n        # Assuming there is a DELETE endpoint to remove demo by clientSlug (not in PRD, so skip if not)\n        if client_slug_created:\n            try:\n                del_resp = requests.delete(\n                    f\"{BASE_URL}/api/demo/{client_slug_created}\",\n                    headers=HEADERS,\n                    timeout=TIMEOUT,\n                )\n                # Accept success or 404 (already deleted)\n                assert del_resp.status_code in (200, 204, 404), f\"Cleanup failed with status {del_resp.status_code}\"\n            except requests.RequestException:\n                pass  # Ignore cleanup errors\n\n\ntest_demo_creation_initial_response_and_background_processing()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.845Z",
    "modified": "2026-01-09T20:40:20.340Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "eb1e0754-fb75-418f-bf63-9297a920a79b",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC015-Demo Creation - Repository Cloning",
    "description": "Verify demo creation process correctly clones the template repository from the provided GitHub URL, creates the demo directory in client-websites folder, initializes a fresh Git repository with proper branch name, creates initial commit, and handles clone failures with appropriate error messages.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:3001\"\nHEADERS = {\n    \"Content-Type\": \"application/json\"\n}\nTIMEOUT = 30\n\n\ndef test_demo_creation_repository_cloning():\n    \"\"\"\n    Test Case TC015: Demo Creation - Repository Cloning\n    Verify demo creation process correctly clones the template repository from the provided GitHub URL,\n    creates the demo directory in client-websites folder, initializes a fresh Git repository with proper branch name,\n    creates initial commit, and handles clone failures with appropriate error messages.\n    \"\"\"\n    demo_create_url = f\"{BASE_URL}/api/demo/create\"\n    demo_status_url_template = f\"{BASE_URL}/api/demo/status/{{clientSlug}}\"\n\n    # Example valid payload for demo creation\n    # businessName and primaryColor are required; provide a valid GitHub repo URL: use a public github repo known to be cloneable\n    payload = {\n        \"businessName\": \"Test Demo Cloning\",\n        \"primaryColor\": \"#123abc\",\n        \"githubRepoUrl\": \"https://github.com/octocat/Hello-World.git\"\n    }\n\n    client_slug = None\n\n    try:\n        # 1. Create demo by POST api/demo/create\n        resp = requests.post(demo_create_url, json=payload, headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Expected 200 OK on demo create, got {resp.status_code}\"\n        resp_json = resp.json()\n        assert \"clientSlug\" in resp_json, \"Response missing clientSlug\"\n        assert \"status\" in resp_json, \"Response missing status\"\n        assert resp_json[\"status\"] == \"starting\", \"Demo creation initial status should be 'starting'\"\n\n        client_slug = resp_json[\"clientSlug\"]\n\n        # 2. Poll demo status until clone completes or error occurs or timeout\n        # Maximum wait: 5 minutes (300s) with polling every 5s\n        max_wait_seconds = 300\n        poll_interval = 5\n        elapsed = 0\n\n        while elapsed < max_wait_seconds:\n            status_resp = requests.get(demo_status_url_template.format(clientSlug=client_slug), timeout=TIMEOUT)\n            if status_resp.status_code == 404:\n                raise AssertionError(\"Demo status endpoint returned 404 - demo might not exist\")\n            assert status_resp.status_code == 200, f\"Expected 200 OK on status polling, got {status_resp.status_code}\"\n            status_json = status_resp.json()\n\n            # Checking status fields\n            demo_status = status_json.get(\"state\") or status_json.get(\"status\") or None\n            message = status_json.get(\"message\") or \"\"\n            logs = status_json.get(\"logs\", [])\n            if not demo_status:\n                raise AssertionError(\"Demo status response missing 'state' or 'status' key\")\n\n            # Check for failure state\n            if demo_status == \"failed\":\n                raise AssertionError(f\"Demo creation failed: {message}\")\n\n            # Check if cloning step passed successfully\n            # We expect the status to transition through 'cloning' to 'cloned' or similar before next steps\n            # Accept states 'cloned', 'installing', 'organizing', 'prompting', 'triggering', 'running' as success progression\n            if demo_status in [\"cloned\", \"installing\", \"organizing\", \"prompting\", \"triggering\", \"running\", \"completed\"]:\n                break\n\n            # If still in 'starting' or 'cloning', wait and continue polling\n            time.sleep(poll_interval)\n            elapsed += poll_interval\n        else:\n            raise AssertionError(\"Timeout waiting for demo cloning to complete\")\n\n        # 3. Validate expected fields post cloning\n        # Verify demo directory creation: Check 'client-websites/{clientSlug}' likely would be on server side,\n        # but from API perspective, check successful clone reflects in status and logs\n\n        # Confirm branch name initialization: Look for logs indicating branch creation or check status field\n        found_branch_init_log = any(\"branch\" in log.lower() for log in logs)\n        assert found_branch_init_log, \"Expected log evidence of Git branch initialization not found.\"\n\n        # Confirm initial commit creation: look for logs indicating Git commit or \"initial commit\"\n        found_initial_commit_log = any(\n            \"initial commit\" in log.lower() or \"commit\" in log.lower()\n            for log in logs\n        )\n        assert found_initial_commit_log, \"Expected log evidence of initial Git commit not found.\"\n\n        # 4. Simulate clone failure scenario by creating demo with an invalid repository URL\n        invalid_payload = {\n            \"businessName\": \"Test Demo Clone Fail\",\n            \"primaryColor\": \"#654321\",\n            \"githubRepoUrl\": \"https://github.com/invalid-user/invalid-repo.git\"\n        }\n\n        fail_resp = requests.post(demo_create_url, json=invalid_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert fail_resp.status_code == 200, f\"Expected 200 OK even on failure start, got {fail_resp.status_code}\"\n        fail_json = fail_resp.json()\n        fail_client_slug = fail_json.get(\"clientSlug\", None)\n        assert fail_client_slug, \"Failure test response missing clientSlug\"\n\n        # Poll status to capture failure message about clone error\n        elapsed = 0\n        while elapsed < max_wait_seconds:\n            fail_status_resp = requests.get(demo_status_url_template.format(clientSlug=fail_client_slug), timeout=TIMEOUT)\n            assert fail_status_resp.status_code == 200, f\"Expected 200 OK on failure status polling, got {fail_status_resp.status_code}\"\n            fail_status_json = fail_status_resp.json()\n            fail_status = fail_status_json.get(\"state\") or fail_status_json.get(\"status\") or None\n            fail_message = fail_status_json.get(\"message\") or \"\"\n\n            if fail_status == \"failed\":\n                # Verify message indicates clone failure\n                assert \"clone\" in fail_message.lower() or \"repository\" in fail_message.lower(), \\\n                    \"Failure message does not indicate repository cloning issue\"\n                break\n            time.sleep(poll_interval)\n            elapsed += poll_interval\n        else:\n            raise AssertionError(\"Timeout waiting for clone failure status update\")\n\n    finally:\n        # Cleanup: Attempt to delete created demos via API if such endpoint exists\n        # No deletion endpoint is defined in PRD; If exists:\n        # DELETE /api/demo/:clientSlug\n        for slug_to_delete in [client_slug, fail_client_slug if 'fail_client_slug' in locals() else None]:\n            if slug_to_delete:\n                try:\n                    del_resp = requests.delete(f\"{BASE_URL}/api/demo/{slug_to_delete}\", timeout=TIMEOUT)\n                    # Accept 200 or 204 as successful deletion\n                    if del_resp.status_code not in (200, 204, 404):\n                        print(f\"Warning: unexpected status code {del_resp.status_code} on deleting demo {slug_to_delete}\")\n                except Exception:\n                    # Log but ignore cleanup exceptions\n                    pass\n\n\ntest_demo_creation_repository_cloning()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.851Z",
    "modified": "2026-01-09T20:46:09.460Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "c7146af4-0ddd-4655-ac45-497dd0c4089b",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC016-Demo Creation - Dependency Installation",
    "description": "Verify demo creation process runs npm install in the cloned repository directory, handles installation failures gracefully, updates status to 'installing' during dependency installation, and logs installation progress correctly.",
    "code": "",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.857Z",
    "modified": "2026-01-09T20:39:21.857Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "9ee1a3e5-6cdc-4c96-9193-f01951f3a0ba",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC017-Demo Creation - File Organization and Asset Processing",
    "description": "Verify demo creation process detects and creates images directory (src/assets/images, src/images, public/images, etc.), moves uploaded logo and heroImage files to the correct location, validates file extensions and handles unsupported formats, saves demo.context.json with all metadata, and creates proper directory structure.",
    "code": "",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.862Z",
    "modified": "2026-01-09T20:39:21.862Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "8ccaeb11-b9e7-478c-83e5-676084306c5c",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC018-Demo Creation - CURSOR_TASK.md Generation",
    "description": "Verify demo creation process generates CURSOR_TASK.md file in the demo directory, replaces all template placeholders correctly (businessName, clientSlug, colors, fonts, imagesDir, etc.), includes proper task structure with step information, and updates status to 'prompting' during generation.",
    "code": "",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.867Z",
    "modified": "2026-01-09T20:39:21.867Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "9730580e-6a5a-4a48-bb46-b211df4db5ea",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC019-Demo Creation - Cursor Agent Triggering",
    "description": "Verify demo creation process calls triggerCursorAgent function with correct parameters (demoDir and mockTask), adds the task to the Cursor Agent Queue, updates status to 'triggering' then 'running', creates proper task state with baseCommitHash and branchName, and handles agent trigger failures appropriately.",
    "code": "",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.872Z",
    "modified": "2026-01-09T20:39:21.872Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "6d572465-96a7-43db-9e8b-9446c0908ebb",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC020-Demo Creation - Status Tracking",
    "description": "Verify GET /api/demo/status/:clientSlug endpoint returns current demo status with state, message, logs, currentStep, totalSteps, returns 404 for non-existent demos, merges real-time agent logs when demo is in 'running' state, updates status correctly through all stages (starting, cloning, installing, organizing, prompting, triggering, running), and maintains status persistence in demo.status.json file.",
    "code": "",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.878Z",
    "modified": "2026-01-09T20:39:21.878Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "39817367-b8f1-4ced-8d42-e4742a8d7a1b",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC021-Demo Creation - Demo Site Structure Verification",
    "description": "Verify created demo site has correct directory structure with all expected files, package.json exists and is valid, Git repository is properly initialized with correct branch, demo.context.json contains all required metadata fields, CURSOR_TASK.md exists with proper content, state files are created in .cursor directory, and uploaded assets are in correct locations with proper filenames.",
    "code": "",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.883Z",
    "modified": "2026-01-09T20:39:21.883Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "2e59b208-00b9-40ff-8f5e-8e53ffbca41e",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC022-Demo Creation - End-to-End Flow with Agent Integration",
    "description": "Verify complete end-to-end demo creation flow: create demo via API, verify repository cloning completes, verify dependencies install successfully, verify CURSOR_TASK.md is generated with correct content, verify agent is added to queue and triggered, verify status transitions correctly through all stages, verify demo site is fully functional after creation, verify agent processes the task and makes changes, and verify status endpoint provides accurate real-time updates.",
    "code": "",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.889Z",
    "modified": "2026-01-09T20:39:21.889Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "de35497f-3e02-4d37-b049-1b32c5510ca4",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC023-Demo Creation - Error Handling and Cleanup",
    "description": "Verify demo creation handles errors at each stage gracefully, updates status to 'failed' with error message on failure, cleans up partial demo directories on failure when appropriate, prevents duplicate demo creation for same slug, handles file lock issues on Windows correctly, and provides meaningful error messages to the API caller.",
    "code": "",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.895Z",
    "modified": "2026-01-09T20:39:21.895Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "eb6f8b36-38ed-4e0e-93d9-943e3cdb2534",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC024-Demo Creation - Status Manager Integration",
    "description": "Verify DemoStatusManager correctly writes and reads status from demo.status.json, maintains in-memory cache for performance, syncs with TaskStatusManager for agent logs, updates audit log (active-demos.json), handles concurrent status updates atomically, and provides accurate status even during active creation.",
    "code": "",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.900Z",
    "modified": "2026-01-09T20:39:21.900Z"
  },
  {
    "projectId": "3fe51a6d-313f-45d0-ae23-782368d4297e",
    "testId": "b48b6c5a-4ee2-4638-9001-253121581fda",
    "userId": "d4c8a438-b0c1-7003-4dde-d1dfcb43381d",
    "title": "TC025-Demo Creation - Slug Generation and Uniqueness",
    "description": "Verify generateUniqueSlug function normalizes business names to URL-safe slugs, appends unique suffix when slug already exists, handles reserved slugs correctly, prevents slug collisions through proper reservation mechanism, and generates deterministic slugs when manual slug is provided.",
    "code": "",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-09T20:39:21.906Z",
    "modified": "2026-01-09T20:39:21.906Z"
  }
]
