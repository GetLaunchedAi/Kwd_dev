# Multi‑Agent “Create Demo” Workflow (4 Gemini 3 Flash Agents + 1 Validator)

> **Purpose**: Convert the current single‑shot demo creation into a **deterministic, low‑context, step‑based pipeline** that is robust against common Eleventy/template edge cases and “cheap model” failures.

> **Model constraint**: Gemini 3 Flash has limited context → every agent must operate from **small, explicit inputs** and **allow‑listed file sets**, and must emit **machine‑checkable outputs**.

---

## 0) Outcome & Guarantees

### Success criteria

- Site branding (colors + logo light/dark) matches business identity.
- All visible text across **all routes** is rewritten for the new business.
- All images are relevant, licensed/safe, optimized, and correctly wired.
- Site **builds cleanly** and renders without missing assets/links.
- Workflow is **restartable** (idempotent) and supports safe retries.

### Non‑goals (for reliability)

- No major refactors.
- No changing build tooling unless required to fix an error.
- No “creative redesign” beyond color + logo + copy + images.

---

## 1) Key Reliability Principle: “Inventory-Driven Editing”

Cheap models fail when asked to “scan the repo.” Instead:

1. **Backend generates an explicit inventory** of what to edit.
2. Each agent is instructed to **touch only** inventory items.
3. Each agent writes a strict `DEMO_STEP_OUTPUT.json`.
4. Orchestrator advances steps only when outputs validate.

---

## 2) Required Files (Created Per Demo)

All files live in the demo workspace folder (e.g., `client-websites/<slug>/`).

### 2.1 `demo.context.json` (input)

Business info + tone + services + location + keywords.

**Must include**:

- `businessName`, `tagline`, `services[]`, `serviceAreas[]`
- `tone` (e.g., professional, friendly, premium)
- `primaryColor` (optional), `secondaryColor` (optional)
- `logoPath` (optional)
- `imageStyle` (optional, e.g., “modern, natural light, minimal”)

### 2.2 `demo.inventory.json` (generated by backend scanner) ✅ critical

A deterministic allow‑list so agents don’t “explore.”

**Must include**:

- `pages[]`: list of source files that produce routes (md/njk/html)
- `partials[]`: header/footer/nav/cta includes used site‑wide
- `dataTextFiles[]`: JSON/YAML/data files containing visible copy
- `seoFiles[]`: any templates/partials for `<title>`, meta, OG, JSON‑LD
- `themeFiles[]`: CSS vars, Tailwind config, global tokens
- `logoTargets[]`: files that reference logos
- `imageSlots[]`: all detected image references (img src, picture, css bg)

**Example image slot record**:

```json
{
  "id": "home-hero",
  "file": "src/index.njk",
  "type": "img|css-bg|picture|data-driven",
  "selectorHint": "img.hero",
  "currentRef": "/assets/img/hero.jpg",
  "desiredAspect": "16:9",
  "minWidth": 1600,
  "altHint": "Hero image for homepage"
}
```

### 2.3 `demo.workflow.json` (state)

Tracks step progression + retry counts.

```json
{ "slug": "acme-plumbing", "currentStep": 1, "status": "running", "retries": { "1": 0, "2": 0, "3": 0, "4": 0, "5": 0 } }
```

### 2.4 `DEMO_STEP_OUTPUT.json` (required output per step) ✅ gate file

Must be valid JSON.

```json
{
  "step": 2,
  "status": "done|blocked",
  "touchedFiles": ["src/index.njk"],
  "notes": "Rewrote all copy for brand voice.",
  "blockers": [],
  "nextStep": 3
}
```

### 2.5 `demo.images.manifest.json` (produced by Step 3)

The plan that Step 4 applies deterministically.

### 2.6 `demo.runlog.md` (optional)

Append short logs per step (helps debugging without huge context).

---

## 3) Orchestrator Changes (Backend)

### 3.1 Create an inventory scanner (Step 0.5)

Add a backend function (e.g., `src/demo/inventoryScanner.ts`) that:

- Finds pages:
  - `src/**/*.md`, `src/**/*.njk`, `src/**/*.html`
  - Collections/pagination templates (detect Eleventy `pagination` keys)
- Finds partials:
  - `src/_includes/**/*` and any layout files referenced by front matter
- Finds data text sources:
  - `src/_data/**/*.(json|yaml|yml)` and `client.json`
- Finds theme sources:
  - global CSS (`theme.css`, `styles.css`), Tailwind config, tokens
- Finds images:
  - `<img src=...>`, `<source srcset=...>`, `background-image: url(...)`
  - data-driven image references (JSON/YAML keys like `image`, `heroImage`)

**Edge case coverage**:

- Generated pages via collections/tags/pagination must be detected as routes or flagged as “generated route patterns.”
- If scanner can’t map a file to a route, keep `route: null` but still include in `pages[]`.

### 3.2 Enforce step gating + idempotency

Implement a step runner (e.g., `src/demo/demoStepManager.ts`):

- Writes `CURSOR_TASK.md` from template for step N
- Clears old `DEMO_STEP_OUTPUT.json` before starting a step
- Triggers Cursor with task id: `demo-<slug>-step<N>`
- On completion, **validates**:
  - Output file exists
  - JSON parse succeeds
  - `status` is `done` before continuing

### 3.3 Add validation gates using Agent 5

To prevent cascading failures, run **Agent 5** after each content-changing step:

- Recommended gate sequence:
  - Step 1 → **Validate** → Step 2 → **Validate** → Step 3 → (optional validate) → Step 4 → **Validate Final**
- If you want fewer runs: validate at minimum after Step 2 and Step 4.

### 3.4 Retry policy (safe + bounded)

- If a step returns `blocked`:
  - Orchestrator stops and surfaces blockers to the user UI.
- If output JSON is missing/invalid:
  - Increment retry count for that step
  - Re-run the same step once with a “fix output JSON format” instruction appended
  - After 2 failures, stop.

### 3.5 Concurrency safety (multiple demos at once)

- Store workflow state per demo folder only.
- Ensure any shared tools (image downloader cache) use demo-specific subfolders:
  - `assets/demo/<slug>/...`
- Avoid global temp paths unless they’re namespaced by slug.

---

## 4) Agent Work Breakdown (Gemini 3 Flash Friendly)

Each agent prompt MUST:

- Reference only `demo.context.json`, `demo.inventory.json`, and step-specific artifacts
- Include **explicit allow‑listed file sets**
- Require **valid JSON output** to `DEMO_STEP_OUTPUT.json`
- Prohibit refactors, renames, and broad exploration

---

# Agent 1 — Branding + client.json + Light/Dark Logo + Theme Colors

## Inputs

- `demo.context.json`
- `demo.inventory.json` → `themeFiles[]`, `logoTargets[]`, `dataTextFiles[]` (if includes business name)
- Existing logo asset(s) (if present)

## Tasks

1. **Update business config**:

   - Populate `client.json` (or equivalent) with name, contact, services.
   - Update global data files in `dataTextFiles[]` ONLY if inventory indicates they contain “brand identity text.”

2. **Logo variants**:

   - Create `logo-light` and `logo-dark` versions.
   - Prefer SVG; otherwise create PNG variants (no transparency mistakes).
   - Update references in `logoTargets[]` to switch logo based on theme:
     - `<picture>` with `prefers-color-scheme`, or
     - CSS class `.dark` toggles, or
     - existing theme mechanism

3. **Theme colors**:

   - Update site tokens in `themeFiles[]` (CSS vars and/or Tailwind tokens).
   - **Guarantee contrast**:
     - Ensure button text, links, headings meet readability in both modes.
     - If primary color fails contrast, adjust shade (document in notes).

4. **Update favicon/OG if inventory includes targets**:

   - Only if `seoFiles[]` contains OG image references.

## Edge cases handled

- Multiple theme sources: Tailwind + CSS vars + inline styles
- Logo referenced in multiple places (header/footer/mobile nav)
- Dark mode uses inverted backgrounds → ensure logo is visible
- Missing logo: generate placeholders using business initials + primary color

## Required output

Write `DEMO_STEP_OUTPUT.json` with:

- `touchedFiles`
- `notes` including how colors were chosen/adjusted
- `status: done|blocked`

---

# Agent 2 — Copywriting Across All Routes + Shared Partials

## Inputs

- `demo.context.json`
- `demo.inventory.json` → `pages[]`, `partials[]`, `dataTextFiles[]`, `seoFiles[]`

## Tasks

1. Rewrite copy for **every** file listed in:

   - `pages[]` (all)
   - `partials[]` (all that contain text)
   - `dataTextFiles[]` (only keys that drive visible text)

2. Update SEO content:

   - `<title>`, meta description, OG title/description
   - JSON‑LD / schema if present (name, url, services, area served)

3. Preserve structure:

   - Do not delete sections unless clearly template-only and repeated
   - Keep nav routes consistent

4. Make copy deterministic:

   - No “Lorem ipsum”
   - Match `tone`
   - Include services and differentiators from `demo.context.json`

## Edge cases handled

- Text in includes/layouts rather than pages
- Generated pages: if scanner identifies collection templates, rewrite those templates too
- Prevent “overwriting config”: only edit files on allow‑list
- Ensure CTAs and forms reference correct business name

## Required output

`DEMO_STEP_OUTPUT.json` + list of all updated pages/partials.

---

# Agent 3 — Image Slot Audit + Manifest (No Downloads Yet)

## Inputs

- `demo.context.json`
- `demo.inventory.json` → `imageSlots[]`, `pages[]` (for context)
- The updated copy from Step 2

## Tasks

1. For each `imageSlots[]` entry:

   - Read the surrounding section text to infer intent (hero, service card, testimonial, about, gallery)
   - Produce a **deterministic manifest record**:
     - `slotId`, `query`, `prompt`, `aspect`, `styleTags`, `filename`, `alt`

2. Decide source:

   - `sourceType: "search"` when stock photo is OK
   - `sourceType: "generate"` when specific concept/branding requires generation

3. Performance constraints:

   - Prefer **WebP** (or AVIF if you support it)
   - Define `maxFileKB` targets (e.g., 250–500KB for large hero)

4. Licensing constraints:

   - If using search sources, restrict to known safe providers your tool supports.

## Edge cases handled

- CSS background images
- Picture/srcset blocks
- Data-driven images in JSON/YAML
- Missing `imageSlots`: if none exist but pages contain sections that obviously need imagery, add “new slots” and specify insertion points as notes

## Outputs

- Write `demo.images.manifest.json`
- Write `DEMO_STEP_OUTPUT.json`

---

# Agent 4 — Image Apply (Use Image Tool) + Wire Into Site

## Inputs

- `demo.images.manifest.json`
- `demo.inventory.json` → `imageSlots[]`, plus any `assetsDir` convention
- Image tool access (ImageRetriever or generator)

## Tasks

1. For each manifest entry:

   - Acquire image via tool:
     - search or generate as specified
   - Save to a consistent path:
     - `src/assets/images/demo/<slug>/<filename>.webp`
   - Ensure sizing/compression targets (convert if needed)

2. Wire image into site:

   - Update `<img src>`, `srcset`, CSS background urls, or data refs
   - Update `alt` text from manifest

3. Prevent layout breakage:

   - Respect `desiredAspect`
   - If container expects fixed ratio, crop/resize appropriately

4. Clean up:

   - Do not delete old images unless sure they’re unused
   - Prefer leaving old assets but removing references

## Edge cases handled

- Wrong path separators (Windows vs Linux)
- Case-sensitive filenames
- Large file sizes / slow pages
- Duplicate filenames (namespace by slug + slotId)
- Missing image tool results → fallback to generation or safe placeholder

## Outputs

- `DEMO_STEP_OUTPUT.json` listing all asset files created and updated references

---

# Agent 5 — Validator (Build + Errors + Quick Runtime Sanity)

> This agent is the “quality gate.” It should have a tiny prompt and is allowed to fix only what’s necessary to build.

## Inputs

- Entire workspace folder
- `demo.workflow.json`, latest step output, and any build command info

## Tasks

1. Determine build command:

   - If `package.json` has `scripts.build`, run that
   - Else try `npx @11ty/eleventy` build if Eleventy site

2. Fix build errors (minimal changes):

   - Missing includes
   - Broken imports/paths
   - Invalid front matter / JSON/YAML parse errors
   - Broken image references (file not found)

3. Validate critical checks:

   - No missing asset references in HTML output (basic grep)
   - No obvious broken links in nav (ensure href routes exist in inventory)
   - Ensure dark/light logo switching works (check referenced filenames exist)

4. Write results:

   - `DEMO_VALIDATION_REPORT.json` (or markdown) with:
     - commands run
     - errors found
     - files fixed

## Edge cases handled

- Step output says “done” but site doesn’t build
- Invalid JSON output from earlier step breaks pipeline
- Tool-generated images missing or wrong extension
- Eleventy collections failing due to missing data keys

---

## 5) Pipeline Control Flow (Recommended)

### Default (most robust)

1. Step 0: clone template + write `demo.context.json`
2. Step 0.5: generate `demo.inventory.json`
3. Step 1: Branding
4. Step 5: Validate (Gate)
5. Step 2: Copy
6. Step 5: Validate (Gate)
7. Step 3: Image manifest
8. Step 4: Apply images
9. Step 5: Validate (Final Gate)
10. Mark demo complete

### Fast mode (fewer runs)

- Validate only after Step 2 and Step 4

---

## 6) “Cheap Model” Guardrails (Put These In Every Step Prompt)

- **Do not scan the repo**. Only touch allow‑listed files from `demo.inventory.json`.
- **Do not rename folders**.
- **Do not change build tooling** unless required to fix a build error (Validator only).
- **Always output valid JSON** to `DEMO_STEP_OUTPUT.json`.
- If unsure, set `status: "blocked"` with a clear `blockers[]` list.

---

## 7) Known Edge Cases & How This Plan Addresses Them

### A) Missing pages (collections/pagination/tags)

- Inventory scanner must detect:
  - pagination templates and collection files
  - route patterns (e.g., `/blog/*`)
- Copy agent edits templates driving collections, not only output routes.

### B) Stale inventory after copy changes

- If Step 2 changes structure significantly:
  - Re-run inventory scan before Step 3 (recommended)
- Or Step 3 treats “missing slot” as blocker.

### C) Multiple theme sources

- Branding agent updates ALL `themeFiles[]` and notes where tokens live.
- Validator catches CSS build errors.

### D) Licensing / unsafe images

- Step 3 restricts source types.
- Step 4 only uses approved tools/providers.
- Manifest includes `source` metadata.

### E) Performance regressions

- Manifest specifies format and size targets.
- Step 4 enforces compression/resizing.
- Validator checks for egregious asset sizes (optional).

### F) Cross-platform path/case issues

- Step 4 uses forward slashes in templates where possible.
- Validator checks file exists with exact casing.

### G) Partial retries and duplication

- Use deterministic filenames:
  - `<slug>__<slotId>.webp`
- Orchestrator clears gate outputs before reruns.
- Step 4 does “overwrite if exists” rather than duplicating.

---

## 8) Implementation Checklist (Engineering)

### Backend

- [ ] Add `inventoryScanner.ts`
- [ ] Add `demoStepManager.ts` (writes prompt, clears outputs, triggers agent)
- [ ] Extend orchestrator step router for `demo-<slug>-stepN`
- [ ] Add validation gating (Agent 5 invocation)
- [ ] Add bounded retry logic + UI feedback

### Prompts

- [ ] `prompts/demo/step1_branding.md`
- [ ] `prompts/demo/step2_copy.md`
- [ ] `prompts/demo/step3_image_manifest.md`
- [ ] `prompts/demo/step4_images_apply.md`
- [ ] `prompts/demo/step5_validate.md`

### UX / Status

- [ ] Show current step + blockers in UI
- [ ] Provide “retry step” and “restart workflow” buttons

---

## 9) Deliverables Per Step (Quick Reference)

| Step | Agent | Output Artifact | Gate |

|------|-------|------------------|------|

| 1 | Branding | `DEMO_STEP_OUTPUT.json` | Validate |

| 2 | Copy | `DEMO_STEP_OUTPUT.json` | Validate |

| 3 | Image Plan | `demo.images.manifest.json` + output | Optional |

| 4 | Image Apply | assets + output | Validate |

| 5 | Validator | `DEMO_VALIDATION_REPORT.json` | Required |

---

## 10) Notes for Your Workspace

- If your image tool is local (e.g., `../../ImageRetriever`), hardcode the command in Step 4 prompt and keep it consistent.
- Keep each prompt under ~120 lines to avoid Gemini Flash drifting.
- Treat `demo.inventory.json` as the single source of truth; if it’s wrong, fix the scanner, not the agent prompts.